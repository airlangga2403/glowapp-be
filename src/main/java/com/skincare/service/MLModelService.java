// ========================================
// COMPLETE ML MODEL SERVICE
// Load Decision Tree Rules from Python Training
// ========================================
package com.skincare.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.skincare.entity.Product;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.*;
import java.util.*;

@Service
@Slf4j
public class MLModelService {

    @Autowired
    private ObjectMapper objectMapper;

    // Decision tree rules from Python training
    private Map<String, Object> decisionTreeRules;
    private Map<String, Double> featureWeights;
    private Map<String, Object> scoringComponents;
    private Map<String, Object> rulesConfig;

    /**
     * ===================================================================
     * INITIALIZATION: Load Decision Tree Rules from Python Training
     * ===================================================================
     * File: decision_tree_rules.json (generated by Python script)
     */
    @PostConstruct
    public void init() {
        try {
            log.info("╔═══════════════════════════════════════════════════════════════╗");
            log.info("║         ML MODEL SERVICE INITIALIZATION                      ║");
            log.info("╚═══════════════════════════════════════════════════════════════╝");

            loadDecisionTreeRules();

            log.info("✓ ML Model Service initialized successfully!");
            log.info("  Model Type: {}", decisionTreeRules.get("model_type"));
            log.info("  Version: {}", decisionTreeRules.get("version"));
            log.info("  Trained Date: {}", decisionTreeRules.get("trained_date"));
            log.info("");
            log.info("Feature Importance Weights:");
            featureWeights.entrySet().stream()
                    .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
                    .forEach(e -> log.info("  {}: {}",
                            String.format("%-25s", e.getKey()),
                            String.format("%.4f", e.getValue())));
            log.info("");

        } catch (Exception e) {
            log.error("✗ CRITICAL: Failed to initialize ML Model Service", e);
            throw new RuntimeException("Failed to load ML model resources. Check if decision_tree_rules.json exists in resources folder.", e);
        }
    }

    /**
     * Load decision tree rules from JSON file
     */
    private void loadDecisionTreeRules() throws IOException {
        log.info("Loading decision_tree_rules.json...");

        InputStream inputStream = new ClassPathResource("decision_tree_rules.json").getInputStream();
        decisionTreeRules = objectMapper.readValue(inputStream, new TypeReference<Map<String, Object>>(){});

        // Extract components
        featureWeights = (Map<String, Double>) decisionTreeRules.get("feature_weights");
        rulesConfig = (Map<String, Object>) decisionTreeRules.get("rules");
        scoringComponents = (Map<String, Object>) rulesConfig.get("scoring_components");

        log.info("✓ Decision tree rules loaded successfully");
    }

    /**
     * ===================================================================
     * MAIN METHOD: Calculate Match Score for Product
     * ===================================================================
     *
     * This method applies the EXACT SAME scoring logic as Python training.
     * Uses decision tree rules from decision_tree_rules.json
     *
     * @param product - Product from database
     * @param budget - User's budget
     * @param skinType - User's skin type (COMBINATION, DRY, NORMAL, OILY, SENSITIVE)
     * @param hasAllergy - Whether user has allergies
     * @param category - Product category (Moisturizer, Cleanser, etc)
     * @return Match score (0-100), or 0 if product doesn't pass hard constraints
     */
    public double predictMatchScore(Product product, double budget, String skinType,
                                    boolean hasAllergy, String category) {

        // ========== STEP 1: APPLY HARD CONSTRAINTS ==========
        Map<String, Boolean> hardConstraints = (Map<String, Boolean>) rulesConfig.get("hard_constraints");

        // Constraint 1: Price must be within budget
        if (Boolean.TRUE.equals(hardConstraints.get("price_must_be_within_budget"))) {
            if (product.getPrice().doubleValue() > budget) {
                log.trace("  ✗ {} - Price ${} > Budget ${}",
                        product.getName(), product.getPrice(), budget);
                return 0.0;
            }
        }

        // Constraint 2: Skin type must match
        if (Boolean.TRUE.equals(hardConstraints.get("skin_type_must_match"))) {
            if (!product.isSuitableForSkinType(skinType)) {
                log.trace("  ✗ {} - Not suitable for {} skin",
                        product.getName(), skinType);
                return 0.0;
            }
        }

        // Constraint 3: Category must match
        if (Boolean.TRUE.equals(hardConstraints.get("category_must_match"))) {
            if (!product.getCategory().getName()
                    .equalsIgnoreCase(category)) {
                log.trace("  ✗ {} - Category mismatch (want: {}, got: {})",
                        product.getName(), category, product.getCategory());
                return 0.0;
            }
        }

        // Constraint 4: Stock must be available
        if (Boolean.TRUE.equals(hardConstraints.get("stock_must_be_available"))) {
            if (product.getStockQuantity() == null || product.getStockQuantity() <= 0) {
                log.trace("  ✗ {} - Out of stock", product.getName());
                return 0.0;
            }
        }

        // ========== STEP 2: CALCULATE SCORE USING PYTHON RULES ==========

        double baseScore = ((Number) rulesConfig.get("base_score")).doubleValue();
        double finalScore = baseScore;

        // Component 1: Rank Score (Product Rating Quality)
        Map<String, Object> rankScoreConfig = (Map<String, Object>) scoringComponents.get("rank_score");
        double rankMaxPoints = ((Number) rankScoreConfig.get("max_points")).doubleValue();
        double rankScore = (product.getRating().doubleValue() / 5.0) * rankMaxPoints;
        finalScore += rankScore;

        // Component 2: Price Efficiency (Cheaper relative to budget = better)
        Map<String, Object> priceEffConfig = (Map<String, Object>) scoringComponents.get("price_efficiency");
        double priceMaxPoints = ((Number) priceEffConfig.get("max_points")).doubleValue();
        double priceUtilization = product.getPrice().doubleValue() / budget;
        double priceScore = (1.0 - priceUtilization) * priceMaxPoints;
        finalScore += priceScore;

        // Component 3: Value Score Bonus (Quality to price ratio)
        Map<String, Object> valueConfig = (Map<String, Object>) scoringComponents.get("value_score_bonus");
        double valueMaxPoints = ((Number) valueConfig.get("max_points")).doubleValue();
        double valueBonus = Math.min(valueMaxPoints, product.getValueScore().doubleValue() * 10.0);
        finalScore += valueBonus;

        // Component 4: Allergen Penalty
        Map<String, Object> allergenConfig = (Map<String, Object>) scoringComponents.get("allergen_penalty");
        double allergenMaxPenalty = ((Number) allergenConfig.get("max_penalty")).doubleValue();
        double allergenPenalty;
        if (hasAllergy) {
            // User has allergy: harsh penalty (3x multiplier)
            allergenPenalty = Math.min(allergenMaxPenalty, product.getAllergenCount() * 3.0);
        } else {
            // User doesn't have allergy: mild penalty (1x multiplier)
            allergenPenalty = Math.min(allergenMaxPenalty, product.getAllergenCount() * 1.0);
        }
        finalScore -= allergenPenalty;

        // Component 5: Beneficial Ingredients Bonus
        Map<String, Object> beneficialConfig = (Map<String, Object>) scoringComponents.get("beneficial_bonus");
        double beneficialMaxPoints = ((Number) beneficialConfig.get("max_points")).doubleValue();
        double beneficialBonus = Math.min(beneficialMaxPoints, product.getBeneficialCount() * 1.5);
        finalScore += beneficialBonus;

        // Component 6: Quality Score Bonus (Normalized product quality)
        Map<String, Object> qualityConfig = (Map<String, Object>) scoringComponents.get("quality_score_bonus");
        double qualityMaxPoints = ((Number) qualityConfig.get("max_points")).doubleValue();
        double qualityBonus = product.getQualityScore().doubleValue() * qualityMaxPoints;
        finalScore += qualityBonus;

        // ========== STEP 3: NORMALIZE TO 0-100 RANGE ==========
        double minScore = ((Number) rulesConfig.get("min_score")).doubleValue();
        double maxScore = ((Number) rulesConfig.get("max_score")).doubleValue();
        finalScore = Math.max(minScore, Math.min(maxScore, finalScore));

        // ========== STEP 4: LOG DETAILED BREAKDOWN (DEBUG MODE) ==========
        if (log.isDebugEnabled()) {
            log.debug("┌─────────────────────────────────────────────────────────────┐");
            log.debug("│ SCORING BREAKDOWN: {}", truncate(product.getName(), 40));
            log.debug("├─────────────────────────────────────────────────────────────┤");
            log.debug("│ Base Score:              {:>6.2f}", baseScore);
            log.debug("│ + Rank Score:            {:>6.2f}  (rating: {})", rankScore, product.getRating());
            log.debug("│ + Price Efficiency:      {:>6.2f}  (${} / ${})", priceScore, product.getPrice(), budget);
            log.debug("│ + Value Bonus:           {:>6.2f}  (value_score: {})", valueBonus, product.getValueScore());
            log.debug("│ - Allergen Penalty:      {:>6.2f}  (count: {}, allergy: {})",
                    allergenPenalty, product.getAllergenCount(), hasAllergy);
            log.debug("│ + Beneficial Bonus:      {:>6.2f}  (count: {})", beneficialBonus, product.getBeneficialCount());
            log.debug("│ + Quality Bonus:         {:>6.2f}  (quality: {})", qualityBonus, product.getQualityScore());
            log.debug("├─────────────────────────────────────────────────────────────┤");
            log.debug("│ FINAL SCORE:             {:>6.2f}", finalScore);
            log.debug("└─────────────────────────────────────────────────────────────┘");
        }

        return finalScore;
    }

    /**
     * Get model information for API endpoint
     */
    public Map<String, Object> getModelInfo() {
        Map<String, Object> info = new HashMap<>();
        info.put("version", decisionTreeRules.get("version"));
        info.put("model_type", decisionTreeRules.get("model_type"));
        info.put("trained_date", decisionTreeRules.get("trained_date"));
        info.put("feature_weights", featureWeights);

        // Add scoring rules summary
        Map<String, Object> rulesSummary = new HashMap<>();
        rulesSummary.put("base_score", rulesConfig.get("base_score"));
        rulesSummary.put("threshold_score", rulesConfig.get("threshold_score"));
        rulesSummary.put("top_n_results", rulesConfig.get("top_n_results"));
        info.put("rules_summary", rulesSummary);

        // Add validation samples if available
        if (decisionTreeRules.containsKey("validation_samples")) {
            info.put("validation_samples", decisionTreeRules.get("validation_samples"));
        }

        return info;
    }

    /**
     * Get threshold score from rules
     */
    public double getThresholdScore() {
        return ((Number) rulesConfig.get("threshold_score")).doubleValue();
    }

    /**
     * Check if model is loaded and ready
     */
    public boolean isModelLoaded() {
        return decisionTreeRules != null &&
                featureWeights != null &&
                scoringComponents != null;
    }

    /**
     * Get feature weight for specific feature
     */
    public double getFeatureWeight(String featureName) {
        return featureWeights.getOrDefault(featureName, 0.0);
    }

    /**
     * Get all scoring components configuration
     */
    public Map<String, Object> getScoringComponents() {
        return new HashMap<>(scoringComponents);
    }

    /**
     * Validate product has all required ML features
     */
    public boolean hasRequiredFeatures(Product product) {
        return product.getRating() != null &&
                product.getPrice() != null &&
                product.getAllergenCount() != null &&
                product.getBeneficialCount() != null &&
                product.getQualityScore() != null &&
                product.getValueScore() != null;
    }

    // ========== HELPER METHODS ==========

    private String truncate(String str, int maxLength) {
        if (str == null || str.length() <= maxLength) return str;
        return str.substring(0, maxLength - 3) + "...";
    }
}